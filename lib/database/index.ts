import Dexie, { Table } from 'dexie'
import { DatabaseLock } from './db-lock'
import { calculateLevel } from '../types/dashboard'
import type { StatType } from '../types/game-common'
import type { ActivityVerification, EquipmentInventory } from './types'

// 기본 인터페이스들
export interface UserProfile {
  id?: number
  userId: string
  email: string
  name: string
  avatar?: string
  level: number
  experience: number // 기존 필드 (deprecated - totalExperience로 이전 예정)
  totalExperience?: number // 모든 스탯의 총 경험치
  currentExperience?: number // 현재 레벨에서의 경험치
  dataVersion?: number // 스키마 버전 관리
  createdAt: Date
  updatedAt: Date
}

export interface Stat {
  id?: number
  userId: string
  type: 'health' | 'learning' | 'relationship' | 'achievement'
  level: number
  experience: number
  totalActivities: number
  updatedAt: Date
}

export interface Activity {
  id?: number
  userId: string
  statType: StatType
  activityName: string
  description?: string
  quality: 'D' | 'C' | 'B' | 'A' | 'S'
  experience: number
  timestamp: Date
  location?: string
  duration?: number // 분 단위
  mediaUrl?: string
  tags?: string[]
  metadata?: {
    device?: string
    appVersion?: string
    method: 'manual' | 'voice' | 'ai_suggestion' | 'quick_action'
    voiceTranscript?: string
    autoGenerated?: boolean
  }
}

export interface Mission {
  id?: number
  userId: string
  title: string
  description: string
  type: 'daily' | 'weekly' | 'monthly' | 'event'
  statType: 'health' | 'learning' | 'relationship' | 'achievement'
  requirements: {
    count: number
    experience: number
  }
  progress: number
  completed: boolean
  rewards: {
    experience: number
    coins?: number
    items?: string[]
  }
  startDate: Date
  endDate: Date
  completedAt?: Date
}

export interface FeedPost {
  id?: number
  userId: string
  content: string
  images?: string[]
  statType?: 'health' | 'learning' | 'relationship' | 'achievement'
  activityId?: number
  likes: number
  comments: number
  createdAt: Date
  updatedAt: Date
  encrypted?: boolean
}

export interface FeedComment {
  id?: number
  postId: number
  userId: string
  content: string
  createdAt: Date
}

export interface FeedReaction {
  id?: number
  postId: number
  userId: string
  type: 'want' | 'respect' | 'support' | 'verify'
  createdAt: Date
}

export interface Investment {
  id?: number
  investorId: string
  recipientId: string
  amount: number
  currency: string
  type: 'investment' | 'donation' | 'sponsorship'
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled'
  description?: string
  receipt?: string
  createdAt: Date
  updatedAt: Date
}

export interface Character {
  id?: number
  userId: string
  appearance: {
    base: string
    hair?: string
    outfit?: string
    accessory?: string
    background?: string
  }
  lastReset: Date
  updatedAt: Date
}

// 장비 관련 인터페이스들
export interface UserEquipment {
  id?: number
  userId: string
  equipmentId: string
  type: 'weapon' | 'armor' | 'accessory'
  rarity: 'common' | 'rare' | 'epic' | 'legendary'
  enhancementLevel: number
  isEquipped: boolean
  slot?: string  // 'accessory1' | 'accessory2' | 'accessory3' for accessories
  acquiredAt: Date
  updatedAt: Date
}

// 아이템 메타데이터 타입
export interface ItemMetadata {
  durability?: number
  charges?: number
  expiresAt?: Date
  [key: string]: unknown
}

export interface UserInventory {
  id?: number
  userId: string
  itemType: 'equipment' | 'consumable' | 'material' | 'currency'
  itemId: string
  quantity: number
  metadata?: ItemMetadata  // 아이템별 추가 정보
  updatedAt: Date
}

export interface UserResources {
  id?: number
  userId: string
  gold: number
  energy: number
  maxEnergy: number
  lastEnergyUpdate: Date
  premiumCurrency: number
  updatedAt: Date
}

export interface UserAchievement {
  id?: number
  userId: string
  achievementId: string
  progress: number
  completed: boolean
  completedAt?: Date
  claimedAt?: Date
  updatedAt: Date
}

// 업적 상태 데이터 타입
export interface AchievementStateData {
  unlockedAchievements: Set<string>
  claimedAchievements: Set<string>
  trackedProgress: Map<string, number>
  statistics: Record<string, number>
}

// 컬렉션 상태 데이터 타입
export interface CollectionStateData {
  monsters?: {
    discovered: Set<string>
    firstKills: Map<string, Date>
    killCounts: Map<string, number>
  }
  items?: {
    discovered: Set<string>
    firstObtained: Map<string, Date>
    totalObtained: Map<string, number>
  }
}

export interface AchievementState {
  id?: number
  userId: string
  stateData: string // JSON 문자열로 저장된 AchievementStateData
  updatedAt: Date
}

// 플레이어 데이터 타입들
export type PlayerDataValue =
  | string
  | number
  | boolean
  | Date
  | { [key: string]: PlayerDataValue }
  | PlayerDataValue[]

// 키-값 저장소용 인터페이스
export interface PlayerData {
  id: string
  data: PlayerDataValue
  updatedAt: Date
}

// 메타데이터 저장용 인터페이스
export interface MetadataEntry {
  id?: number
  key: string
  value: string | number | boolean | Record<string, unknown>
  updatedAt: Date
}

// 설정 테이블용 인터페이스
export interface Setting {
  id?: number
  key: string
  value: string
  updatedAt: Date
}

// 스테이지 진행상황 저장용 인터페이스
export interface StageProgressRecord {
  id?: number
  userId: string
  dungeonId: string
  stageId: string
  status: 'locked' | 'available' | 'in_progress' | 'completed'
  stars: number
  bestTime?: number
  bestScore?: number
  attempts: number
  objectives: string // JSON string of objectives
  firstClearDate?: Date
  lastAttemptDate?: Date
  createdAt: Date
  updatedAt: Date
}

// 컬렉션 상태 저장용 인터페이스
export interface CollectionState {
  id?: number
  userId: string
  type: 'monster' | 'item'
  stateData: string // JSON string of collection state
  updatedAt: Date
}

// 리더보드 엔트리
export interface LeaderboardEntry {
  id?: number
  userId: string
  userName: string
  category: 'total_exp' | 'daily_activity' | 'achievement_score' | 'dungeon_clear' | 'stage_clear' | 'collection_score'
  score: number
  rank?: number
  metadata?: string // JSON string for additional data
  createdAt: Date
  updatedAt: Date
}

// 유저별 누적 점수
export interface UserScore {
  id?: number
  userId: string
  category: string
  totalScore: number
  lastUpdated: Date
}

// 에너지 시스템 인터페이스
export interface PlayerEnergyData {
  id?: number
  userId: string
  current: number
  max: number
  lastRegenTime: Date
  lastDailyBonus?: Date
}

export interface BattleTicketData {
  id?: number
  userId: string
  count: number
  lastReset: Date
}

export interface EnergyTransaction {
  id?: number
  userId: string
  type: 'consume' | 'regen' | 'bonus' | 'purchase' | 'refund'
  amount: number
  reason: string
  timestamp: Date
  beforeAmount: number
  afterAmount: number
}

// 일일 경험치 제한
export interface DailyExpLimit {
  id?: number
  userId: string
  statType: StatType
  date: string // YYYY-MM-DD format
  baseLimit: number
  bonusLimit: number
  currentExp: number
  activityCount: number
  uniqueActivities: number
  violations: number
  lastActivityTime: Date
  streakDays: number
}

// 플레이어 스탯 (별도 관리)
export interface PlayerStats {
  id?: number
  userId: string
  statType: StatType
  level: number
  experience: number
  totalExp: number
  lastUpdated: Date
}

// 학습한 스킬
export interface LearnedSkillData {
  id?: number
  userId: string
  skillId: string
  level: number
  experience: number
  cooldownRemaining: number
  isActive: boolean
  slot?: number
  learnedAt: Date
  lastUsed?: Date
}

// 퀵슬롯 설정
export interface QuickSlotData {
  id?: number
  userId: string
  slot: number // 1-8
  skillId?: string
  updatedAt: Date
}

// 스킬 포인트
export interface SkillPointData {
  id?: number
  userId: string
  totalPoints: number
  availablePoints: number
  updatedAt: Date
}

// 던전 진행 상황
export interface DungeonProgress {
  id?: number
  userId: string
  dungeonId: string
  status: 'available' | 'in_progress' | 'completed' | 'failed'
  attempts: number
  currentChallengeIndex?: number
  completedAt?: Date
  lastAttemptAt?: Date
  energyUsed?: number
  rewards?: {
    exp: number
    coins?: number
    items?: string[]
  }
  createdAt: Date
  updatedAt: Date
}

// 피로도 시스템
export interface FatigueData {
  id?: number
  userId: string
  currentFatigue: number // 0-100
  activityStreak: number
  lastActivityTime: Date
  lastRestTime: Date
  updatedAt: Date
}

export interface FatigueActivity {
  id?: number
  userId: string
  timestamp: Date
  activityCount: number
  fatigueAdded: number
  efficiency: number
}

// 통합 데이터베이스 클래스
export class LifeRPGDatabase extends Dexie {
  // 오프라인 데이터 테이블들
  profiles!: Table<UserProfile>
  stats!: Table<Stat>
  activities!: Table<Activity>
  missions!: Table<Mission>
  feedPosts!: Table<FeedPost>
  feedComments!: Table<FeedComment>
  feedReactions!: Table<FeedReaction>
  investments!: Table<Investment>
  characters!: Table<Character>

  // 장비 및 인벤토리 테이블들
  userEquipments!: Table<UserEquipment>
  userInventory!: Table<UserInventory>
  userResources!: Table<UserResources>

  // 업적 시스템 테이블들
  userAchievements!: Table<UserAchievement>
  achievementStates!: Table<AchievementState>

  // 키-값 저장소
  playerData!: Table<PlayerData>
  settings!: Table<Setting>

  // 확장 테이블들
  stageProgress!: Table<StageProgressRecord>
  collectionStates!: Table<CollectionState>
  leaderboardEntries!: Table<LeaderboardEntry>
  userScores!: Table<UserScore>

  // 에너지 시스템 테이블들
  playerEnergy!: Table<PlayerEnergyData>
  battleTickets!: Table<BattleTicketData>
  energyTransactions!: Table<EnergyTransaction>
  dailyExpLimits!: Table<DailyExpLimit>

  // 추가 테이블
  playerStats!: Table<PlayerStats>
  dungeonProgress!: Table<DungeonProgress>

  // 스킬 시스템 테이블들
  learnedSkills!: Table<LearnedSkillData>
  quickSlots!: Table<QuickSlotData>
  skillPoints!: Table<SkillPointData>

  // 메타데이터 테이블
  metadata!: Table<MetadataEntry>

  // 피로도 시스템 테이블들
  fatigue!: Table<FatigueData>
  fatigueActivities!: Table<FatigueActivity>

  // 활동 검증 시스템 테이블
  verifications!: Table<ActivityVerification>

  // JRPG 시스템 테이블들
  jrpgInventory!: Table<import('./types').JRPGInventory>
  jrpgSkills!: Table<import('./types').JRPGSkills>
  jrpgBattleLogs!: Table<import('./types').JRPGBattleLog>
  jrpgProgress!: Table<import('./types').JRPGProgress>

  constructor() {
    // SSR 환경에서는 데이터베이스 초기화하지 않음
    if (typeof window === 'undefined') {
      super('LifeRPGDatabase')
      // 테이블들을 null로 설정하여 접근 시 오류 방지
      this.profiles = null as unknown as Table<UserProfile>
      this.stats = null as unknown as Table<Stat>
      this.activities = null as unknown as Table<Activity>
      this.missions = null as unknown as Table<Mission>
      this.feedPosts = null as unknown as Table<FeedPost>
      this.feedComments = null as unknown as Table<FeedComment>
      this.feedReactions = null as unknown as Table<FeedReaction>
      this.investments = null as unknown as Table<Investment>
      this.characters = null as unknown as Table<Character>
      this.userEquipments = null as unknown as Table<UserEquipment>
      this.userInventory = null as unknown as Table<UserInventory>
      this.userResources = null as unknown as Table<UserResources>
      this.userAchievements = null as unknown as Table<UserAchievement>
      this.achievementStates = null as unknown as Table<AchievementState>
      this.playerData = null as unknown as Table<PlayerData>
      this.settings = null as unknown as Table<Setting>
      this.stageProgress = null as unknown as Table<StageProgressRecord>
      this.collectionStates = null as unknown as Table<CollectionState>
      this.leaderboardEntries = null as unknown as Table<LeaderboardEntry>
      this.userScores = null as unknown as Table<UserScore>
      this.playerEnergy = null as unknown as Table<PlayerEnergyData>
      this.battleTickets = null as unknown as Table<BattleTicketData>
      this.energyTransactions = null as unknown as Table<EnergyTransaction>
      this.dailyExpLimits = null as unknown as Table<DailyExpLimit>
      this.playerStats = null as unknown as Table<PlayerStats>
      this.dungeonProgress = null as unknown as Table<DungeonProgress>
      this.learnedSkills = null as unknown as Table<LearnedSkillData>
      this.quickSlots = null as unknown as Table<QuickSlotData>
      this.skillPoints = null as unknown as Table<SkillPointData>
      this.metadata = null as unknown as Table<MetadataEntry>
      this.fatigue = null as unknown as Table<FatigueData>
      this.fatigueActivities = null as unknown as Table<FatigueActivity>
      this.verifications = null as unknown as Table<ActivityVerification>
      this.jrpgInventory = null as unknown as Table<import('./types').JRPGInventory>
      this.jrpgSkills = null as unknown as Table<import('./types').JRPGSkills>
      this.jrpgBattleLogs = null as unknown as Table<import('./types').JRPGBattleLog>
      this.jrpgProgress = null as unknown as Table<import('./types').JRPGProgress>
      return
    }

    super('LifeRPGDatabase')

    // 버전 1: 기본 테이블들
    this.version(1).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      playerData: 'id, updatedAt'
    })

    // 버전 2: 피드 및 투자 기능 추가
    this.version(2).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      playerData: 'id, updatedAt'
    })

    // 버전 3: stats 테이블 개선 (단순한 스키마 정의만)
    this.version(3).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId', // 유니크 제약조건 제거, 인덱스만 유지
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      playerData: 'id, updatedAt'
    })

    // 버전 4: characters 테이블 추가
    this.version(4).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt'
    })

    // 버전 5: settings 테이블 추가
    this.version(5).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key'
    })

    // 버전 6: 장비 및 인벤토리 시스템 추가
    this.version(6).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key',
      userEquipments: '++id, userId, equipmentId, [userId+isEquipped]',
      userInventory: '++id, userId, [userId+itemType], [userId+itemId]',
      userResources: '++id, userId'
    })

    // 버전 7: 업적 시스템 추가
    this.version(7).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key',
      userEquipments: '++id, userId, equipmentId, [userId+isEquipped]',
      userInventory: '++id, userId, [userId+itemType], [userId+itemId]',
      userResources: '++id, userId',
      userAchievements: '++id, userId, achievementId, [userId+completed]',
      achievementStates: '++id, userId'
    })

    // 버전 8: 확장 테이블 추가 (던전, 컬렉션, 리더보드)
    this.version(8).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key',
      userEquipments: '++id, userId, equipmentId, [userId+isEquipped]',
      userInventory: '++id, userId, [userId+itemType], [userId+itemId]',
      userResources: '++id, userId',
      userAchievements: '++id, userId, achievementId, [userId+completed]',
      achievementStates: '++id, userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId'
    })

    // 버전 9: dungeonProgress 테이블 추가
    this.version(9).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key',
      userEquipments: '++id, userId, equipmentId, [userId+isEquipped]',
      userInventory: '++id, userId, [userId+itemType], [userId+itemId]',
      userResources: '++id, userId',
      userAchievements: '++id, userId, achievementId, [userId+completed]',
      achievementStates: '++id, userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt'
    })

    // 버전 11: 스킬 시스템 테이블 추가
    this.version(11).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key'
    })

    // 버전 12: 피로도 시스템 테이블 추가
    this.version(12).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key',
      fatigue: '++id, userId',
      fatigueActivities: '++id, userId, timestamp'
    })

    // 버전 13: 활동 검증 시스템 테이블 추가
    this.version(13).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key',
      fatigue: '++id, userId',
      fatigueActivities: '++id, userId, timestamp',
      verifications: '++id, [userId+activityId], userId, timestamp, type, verified'
    })

    // 버전 14: 프로필 스키마 v2 - totalExperience, currentExperience 필드 추가
    this.version(14).stores({
      profiles: '++id, userId, email', // 인덱스는 동일
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key',
      fatigue: '++id, userId',
      fatigueActivities: '++id, userId, timestamp',
      verifications: '++id, [userId+activityId], userId, timestamp, type, verified'
    }).upgrade(async trans => {
      // 프로필 마이그레이션: totalExperience와 currentExperience 필드 추가
      const profiles = await trans.profiles.toArray()
      const stats = await trans.stats.toArray()

      for (const profile of profiles) {
        // 해당 사용자의 모든 스탯 경험치 합계 계산
        const userStats = stats.filter(s => s.userId === profile.userId)
        const totalExp = userStats.reduce((sum, stat) => sum + stat.experience, 0)

        // stat-calculator의 함수를 사용하여 현재 경험치 계산
        const { calculateLevelFromExperience } = await import('@/lib/utils/stat-calculator')
        const { level, currentExp } = calculateLevelFromExperience(totalExp)

        // 프로필 업데이트
        await trans.profiles.update(profile.id!, {
          totalExperience: totalExp,
          currentExperience: currentExp,
          level: level, // 레벨도 재계산하여 업데이트
          dataVersion: 2,
          updatedAt: new Date()
        })
      }
    })

    // 버전 15: JRPG 시스템 테이블 추가
    this.version(15).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key',
      fatigue: '++id, userId',
      fatigueActivities: '++id, userId, timestamp',
      verifications: '++id, [userId+activityId], userId, timestamp, type, verified',
      // JRPG 테이블들
      jrpgInventory: '++id, userId',
      jrpgSkills: '++id, userId',
      jrpgBattleLogs: '++id, userId, dungeonId, timestamp',
      jrpgProgress: '++id, userId'
    })
  }
}

// SSR에서 안전한 더미 데이터베이스 객체
class DummyDatabase extends Dexie {
  profiles!: Dexie.Table<UserProfile, number>
  stats!: Dexie.Table<Stat, number>
  activities!: Dexie.Table<Activity, number>
  missions!: Dexie.Table<Mission, number>
  feedPosts!: Dexie.Table<FeedPost, number>
  feedComments!: Dexie.Table<FeedComment, number>
  feedReactions!: Dexie.Table<FeedReaction, number>
  investments!: Dexie.Table<Investment, number>
  characters!: Dexie.Table<Character, number>
  playerData!: Dexie.Table<PlayerData, string>
  settings!: Dexie.Table<Setting, number>

  constructor() {
    super('DummyDB')
    // SSR에서는 실제로 사용되지 않으므로 버전만 설정
    this.version(1).stores({})
  }
}

// 데이터베이스 인스턴스 생성 (클라이언트에서만)
export const db: LifeRPGDatabase = typeof window !== 'undefined'
  ? new LifeRPGDatabase()
  : new DummyDatabase() as unknown as LifeRPGDatabase

// 데이터베이스 헬퍼 함수들
export const dbHelpers = {
  // 프로필 관련
  async getProfile(userId: string): Promise<UserProfile | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.profiles.where('userId').equals(userId).first() || null
  },

  async updateProfile(userId: string, updates: Partial<UserProfile>) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    const profile = await this.getProfile(userId)
    if (profile) {
      return await db.profiles.update(profile.id!, { ...updates, updatedAt: new Date() })
    }
    return null
  },

  // 스탯 관련
  async getStats(userId: string) {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    let stats = await db.stats.where('userId').equals(userId).toArray()

    // 스탯이 없으면 기본 스탯 생성
    if (stats.length === 0) {
      const defaultStats: Omit<Stat, 'id'>[] = [
        {
          userId,
          type: 'health',
          level: 0,
          experience: 0,
          totalActivities: 0,
          updatedAt: new Date()
        },
        {
          userId,
          type: 'learning',
          level: 0,
          experience: 0,
          totalActivities: 0,
          updatedAt: new Date()
        },
        {
          userId,
          type: 'relationship',
          level: 0,
          experience: 0,
          totalActivities: 0,
          updatedAt: new Date()
        },
        {
          userId,
          type: 'achievement',
          level: 0,
          experience: 0,
          totalActivities: 0,
          updatedAt: new Date()
        }
      ]

      for (const stat of defaultStats) {
        await db.stats.add(stat)
      }

      // 새로 생성된 스탯들 반환
      stats = await db.stats.where('userId').equals(userId).toArray()
    }

    return stats
  },

  async saveStat(stat: Stat) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    // userId와 type으로 기존 스탯 찾기
    const userStats = await db.stats.where('userId').equals(stat.userId).toArray()
    const existing = userStats.find((s) => s.type === stat.type)

    if (existing) {
      // 기존 스탯 업데이트
      return await db.stats.update(existing.id!, {
        ...stat,
        id: existing.id,
        updatedAt: new Date()
      })
    } else {
      // 새 스탯 추가
      return await db.stats.add(stat)
    }
  },

  async updateStat(userId: string, type: Stat['type'], experience: number) {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    // 해당 사용자의 모든 스탯 가져와서 필터링
    const userStats = await db.stats.where('userId').equals(userId).toArray()
    const stat = userStats.find((s) => s.type === type)

    if (stat) {
      const newExperience = stat.experience + experience
      const { level: newLevel } = calculateLevel(newExperience)
      return await db.stats.update(stat.id!, {
        experience: newExperience,
        level: newLevel,
        totalActivities: stat.totalActivities + 1,
        updatedAt: new Date()
      })
    } else {
      // 스탯이 없으면 새로 생성
      const { level: newLevel } = calculateLevel(experience)
      const newStat: Omit<Stat, 'id'> = {
        userId,
        type,
        level: newLevel,
        experience,
        totalActivities: 1,
        updatedAt: new Date()
      }
      return await db.stats.add(newStat)
    }
  },

  // 활동 관련
  async addActivity(activity: Omit<Activity, 'id'>) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    const id = await db.activities.add(activity)
    // 스탯 업데이트
    await this.updateStat(activity.userId, activity.statType, activity.experience)

    // 오프라인일 때 동기화 대기열에 추가 - 나중에 구현
    // if (!navigator.onLine) {
    //   // TODO: Implement sync queue
    // }

    // 전체 활동 객체 반환
    return { ...activity, id }
  },

  async getActivities(userId: string, limit?: number) {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    const query = db.activities
      .where('userId')
      .equals(userId)
      .reverse()

    if (limit) {
      return await query.limit(limit).toArray()
    }

    return await query.toArray()
  },

  async deleteActivity(id: number) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.activities.delete(id)
  },

  async getRecentActivities(userId: string, limit = 10) {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.activities
      .where('userId')
      .equals(userId)
      .reverse()
      .sortBy('timestamp')
      .then((activities) => activities.slice(0, limit))
  },


  async getActivitiesByDateRange(userId: string, startDate: Date, endDate: Date) {
    return await db.activities
      .where('userId')
      .equals(userId)
      .and((activity) => activity.timestamp >= startDate && activity.timestamp <= endDate)
      .toArray()
  },

  // 미션 관련
  async getActiveMissions(userId: string) {
    const now = new Date()
    return await db.missions
      .where('userId')
      .equals(userId)
      .and((mission) => !mission.completed && mission.endDate > now)
      .toArray()
  },

  async updateMissionProgress(missionId: number, progress: number) {
    const mission = await db.missions.get(missionId)
    if (mission) {
      const completed = progress >= mission.requirements.count
      return await db.missions.update(missionId, {
        progress,
        completed,
        completedAt: completed ? new Date() : undefined
      })
    }
  },

  // 플레이어 데이터 (키-값 저장소)
  async getPlayerData(key: string): Promise<PlayerData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.playerData.get(key) || null
  },

  async setPlayerData(key: string, data: PlayerDataValue) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.playerData.put({
      id: key,
      data,
      updatedAt: new Date()
    })
  },


  // 초기 데이터 설정
  async initializeUserData(userId: string, email: string, name: string) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return DatabaseLock.acquire(`init-${userId}`, async() => {
      // 프로필이 이미 존재하는지 확인
      const existingProfile = await db.profiles.where('userId').equals(userId).first()

      if (!existingProfile) {
        // 프로필 생성
        await db.profiles.add({
          userId,
          email,
          name,
          level: 0,
          experience: 0,
          createdAt: new Date(),
          updatedAt: new Date()
        })
      }

      // 초기 스탯 생성 (트랜잭션으로 처리)
      await db.transaction('rw', db.stats, async() => {
        const statTypes: Stat['type'][] = ['health', 'learning', 'relationship', 'achievement']

        for (const type of statTypes) {
          // 이미 존재하는지 확인
          const existing = await db.stats
            .where('[userId+type]')
            .equals([userId, type])
            .first()

          if (!existing) {
            console.log(`📝 Creating stat: ${type}`)
            await db.stats.add({
              userId,
              type,
              level: 0,
              experience: 0,
              totalActivities: 0,
              updatedAt: new Date()
            })
          } else {
            console.log(`✅ Stat already exists: ${type}`)
          }
        }
      })
    })
  },

  // 중복된 스탯 제거
  async removeDuplicateStats(userId: string) {
    if (typeof window === 'undefined' || !db) {
      return { removed: 0, remaining: 0 }
    }
    return db.transaction('rw', db.stats, async() => {
      const stats = await db.stats.where('userId').equals(userId).toArray()
      const uniqueStats = new Map<string, Stat>()

      console.log(`🔍 Checking ${stats.length} stats for duplicates...`)

      // 각 타입별로 가장 높은 레벨과 경험치를 가진 스탯만 유지
      for (const stat of stats) {
        const existing = uniqueStats.get(stat.type)
        if (!existing ||
            stat.level > existing.level ||
            (stat.level === existing.level && stat.experience > existing.experience)) {
          uniqueStats.set(stat.type, stat)
        }
      }

      // 중복된 스탯이 있는 경우 처리
      if (stats.length > uniqueStats.size) {
        console.log(`🧹 Removing duplicate stats: ${stats.length} → ${uniqueStats.size}`)

        // 모든 스탯 삭제
        await db.stats.where('userId').equals(userId).delete()

        // 유니크한 스탯만 다시 저장 (ID 없이)
        const newStats = []
        for (const stat of uniqueStats.values()) {
          const newStat = {
            userId: stat.userId,
            type: stat.type,
            level: stat.level,
            experience: stat.experience,
            totalActivities: stat.totalActivities,
            updatedAt: new Date()
          }
          await db.stats.add(newStat)
          newStats.push(newStat)
        }

        console.log(`✅ Duplicates removed. New stats:`, newStats.map(s => s.type))
        return { removed: stats.length - uniqueStats.size, remaining: uniqueStats.size }
      }

      console.log('✅ No duplicates found')
      return { removed: 0, remaining: stats.length }
    })
  },

  // 장비 관련 함수들
  async getUserEquipments(userId: string): Promise<UserEquipment[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.userEquipments.where('userId').equals(userId).toArray()
  },

  // 장비 인벤토리 가져오기 (player.service에서 사용)
  async getEquipmentInventory(userId: string): Promise<EquipmentInventory | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    const equipments = await db.userEquipments
      .where('userId')
      .equals(userId)
      .toArray()

    if (!equipments.length) {
      return {
        id: 0,
        userId,
        maxSlots: 100,
        currentSlots: 0,
        items: [],
        createdAt: new Date(),
        updatedAt: new Date()
      }
    }

    // userEquipments를 EquipmentInventory 형식으로 변환
    const items = equipments.map(eq => ({
      id: eq.id!,
      inventoryId: 0, // 임시
      itemId: eq.equipmentId,
      type: eq.type,
      rarity: eq.rarity,
      level: 1,
      enhancement: eq.enhancementLevel || 0,
      isEquipped: eq.isEquipped,
      equippedSlot: eq.slot || null,
      obtainedAt: eq.acquiredAt,
      locked: false
    }))

    return {
      id: 0,
      userId,
      maxSlots: 100,
      currentSlots: items.length,
      items,
      createdAt: new Date(),
      updatedAt: new Date()
    }
  },

  async getEquippedItems(userId: string): Promise<UserEquipment[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.userEquipments
      .where('userId')
      .equals(userId)
      .and(item => item.isEquipped === true)
      .toArray()
  },

  async equipItem(userId: string, equipmentId: string, slot?: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const equipment = await db.userEquipments
      .where({ userId, equipmentId })
      .first()

    if (!equipment) {
      return false
    }

    await db.userEquipments.update(equipment.id!, {
      isEquipped: true,
      slot: slot,
      updatedAt: new Date()
    })

    return true
  },

  async unequipItem(userId: string, equipmentId: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const equipment = await db.userEquipments
      .where({ userId, equipmentId })
      .first()

    if (!equipment) {
      return false
    }

    await db.userEquipments.update(equipment.id!, {
      isEquipped: false,
      slot: undefined,
      updatedAt: new Date()
    })

    return true
  },

  async addEquipmentToInventory(userId: string, equipmentId: string, type: string, rarity: string): Promise<number | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    const equipment: Omit<UserEquipment, 'id'> = {
      userId,
      equipmentId,
      type: type as UserEquipment['type'],
      rarity: rarity as UserEquipment['rarity'],
      enhancementLevel: 0,
      isEquipped: false,
      acquiredAt: new Date(),
      updatedAt: new Date()
    }

    return await db.userEquipments.add(equipment)
  },

  // 리소스 관련 함수들
  async getUserResources(userId: string): Promise<UserResources | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    let resources = await db.userResources.where('userId').equals(userId).first()

    if (!resources) {
      // 기본 리소스 생성
      const defaultResources: Omit<UserResources, 'id'> = {
        userId,
        gold: 1000,
        energy: 100,
        maxEnergy: 100,
        lastEnergyUpdate: new Date(),
        premiumCurrency: 0,
        updatedAt: new Date()
      }

      await db.userResources.add(defaultResources)
      resources = await db.userResources.where('userId').equals(userId).first()
    }

    return resources || null
  },

  async updateUserResources(userId: string, updates: Partial<UserResources>): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const resources = await this.getUserResources(userId)
    if (!resources) {
      return false
    }

    await db.userResources.update(resources.id!, {
      ...updates,
      updatedAt: new Date()
    })

    return true
  },

  async spendGold(userId: string, amount: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const resources = await this.getUserResources(userId)
    if (!resources || resources.gold < amount) {
      return false
    }

    await this.updateUserResources(userId, {
      gold: resources.gold - amount
    })

    return true
  },

  async addGold(userId: string, amount: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const resources = await this.getUserResources(userId)
    if (!resources) {
      return false
    }

    await this.updateUserResources(userId, {
      gold: resources.gold + amount
    })

    return true
  },

  // 인벤토리 관련 함수들
  async getInventoryItems(userId: string, itemType?: string): Promise<UserInventory[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    if (itemType) {
      return await db.userInventory
        .where(['userId', 'itemType'])
        .equals([userId, itemType])
        .toArray()
    }

    return await db.userInventory.where('userId').equals(userId).toArray()
  },

  async addInventoryItem(userId: string, itemType: string, itemId: string, quantity = 1): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existingItem = await db.userInventory
      .where(['userId', 'itemId'])
      .equals([userId, itemId])
      .first()

    if (existingItem) {
      await db.userInventory.update(existingItem.id!, {
        quantity: existingItem.quantity + quantity,
        updatedAt: new Date()
      })
    } else {
      const newItem: Omit<UserInventory, 'id'> = {
        userId,
        itemType: itemType as UserInventory['itemType'],
        itemId,
        quantity,
        updatedAt: new Date()
      }
      await db.userInventory.add(newItem)
    }

    return true
  },

  async removeInventoryItem(userId: string, itemId: string, quantity = 1): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const item = await db.userInventory
      .where(['userId', 'itemId'])
      .equals([userId, itemId])
      .first()

    if (!item || item.quantity < quantity) {
      return false
    }

    if (item.quantity === quantity) {
      await db.userInventory.delete(item.id!)
    } else {
      await db.userInventory.update(item.id!, {
        quantity: item.quantity - quantity,
        updatedAt: new Date()
      })
    }

    return true
  },

  // 업적 관련 함수들
  async getUserAchievements(userId: string): Promise<UserAchievement[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.userAchievements.where('userId').equals(userId).toArray()
  },

  async updateAchievementProgress(userId: string, achievementId: string, progress: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const achievement = await db.userAchievements
      .where(['userId', 'achievementId'])
      .equals([userId, achievementId])
      .first()

    if (achievement) {
      await db.userAchievements.update(achievement.id!, {
        progress,
        updatedAt: new Date()
      })
    } else {
      const newAchievement: Omit<UserAchievement, 'id'> = {
        userId,
        achievementId,
        progress,
        completed: false,
        updatedAt: new Date()
      }
      await db.userAchievements.add(newAchievement)
    }

    return true
  },

  async completeAchievement(userId: string, achievementId: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const achievement = await db.userAchievements
      .where(['userId', 'achievementId'])
      .equals([userId, achievementId])
      .first()

    if (achievement) {
      await db.userAchievements.update(achievement.id!, {
        completed: true,
        completedAt: new Date(),
        updatedAt: new Date()
      })
    } else {
      const newAchievement: Omit<UserAchievement, 'id'> = {
        userId,
        achievementId,
        progress: 100,
        completed: true,
        completedAt: new Date(),
        updatedAt: new Date()
      }
      await db.userAchievements.add(newAchievement)
    }

    return true
  },

  async claimAchievementReward(userId: string, achievementId: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const achievement = await db.userAchievements
      .where(['userId', 'achievementId'])
      .equals([userId, achievementId])
      .first()

    if (achievement && achievement.completed && !achievement.claimedAt) {
      await db.userAchievements.update(achievement.id!, {
        claimedAt: new Date(),
        updatedAt: new Date()
      })
      return true
    }

    return false
  },

  async saveAchievementState(userId: string, stateData: AchievementStateData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.achievementStates.where('userId').equals(userId).first()

    if (existing) {
      await db.achievementStates.update(existing.id!, {
        stateData: JSON.stringify(stateData),
        updatedAt: new Date()
      })
    } else {
      const newState: Omit<AchievementState, 'id'> = {
        userId,
        stateData: JSON.stringify(stateData),
        updatedAt: new Date()
      }
      await db.achievementStates.add(newState)
    }

    return true
  },

  async loadAchievementState(userId: string): Promise<AchievementStateData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    const state = await db.achievementStates.where('userId').equals(userId).first()

    if (state) {
      try {
        return JSON.parse(state.stateData)
      } catch (error) {
        console.error('Failed to parse achievement state:', error)
        return null
      }
    }

    return null
  },

  // 스테이지 진행상황 관련 함수들
  async getStageProgress(userId: string, dungeonId: string, stageId: string): Promise<StageProgressRecord | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.stageProgress
      .where(['userId', 'dungeonId', 'stageId'])
      .equals([userId, dungeonId, stageId])
      .first() || null
  },

  async updateStageProgress(userId: string, dungeonId: string, stageId: string, updates: Partial<StageProgressRecord>): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await this.getStageProgress(userId, dungeonId, stageId)

    if (existing && existing.id) {
      await db.stageProgress.update(existing.id, {
        ...updates,
        updatedAt: new Date()
      })
    } else {
      const newProgress: Omit<StageProgressRecord, 'id'> = {
        userId,
        dungeonId,
        stageId,
        status: updates.status || 'locked',
        stars: updates.stars || 0,
        bestTime: updates.bestTime,
        bestScore: updates.bestScore,
        attempts: updates.attempts || 0,
        objectives: updates.objectives || '[]',
        firstClearDate: updates.firstClearDate,
        lastAttemptDate: updates.lastAttemptDate,
        createdAt: new Date(),
        updatedAt: new Date()
      }
      await db.stageProgress.add(newProgress)
    }

    return true
  },

  async getAllStageProgress(userId: string, dungeonId?: string): Promise<StageProgressRecord[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    if (dungeonId) {
      return await db.stageProgress
        .where(['userId', 'dungeonId'])
        .equals([userId, dungeonId])
        .toArray()
    }

    return await db.stageProgress.where('userId').equals(userId).toArray()
  },

  // 컬렉션 관련 함수들
  async saveCollectionState(userId: string, state: CollectionStateData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const type = state.monsters ? 'monster' : 'item'
    const existing = await db.collectionStates
      .where(['userId', 'type'])
      .equals([userId, type])
      .first()

    if (existing && existing.id) {
      await db.collectionStates.update(existing.id, {
        stateData: JSON.stringify(state),
        updatedAt: new Date()
      })
    } else {
      const newState: Omit<CollectionState, 'id'> = {
        userId,
        type: type as 'monster' | 'item',
        stateData: JSON.stringify(state),
        updatedAt: new Date()
      }
      await db.collectionStates.add(newState)
    }

    return true
  },

  async loadCollectionState(userId: string, type: 'monster' | 'item'): Promise<CollectionStateData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    const state = await db.collectionStates
      .where(['userId', 'type'])
      .equals([userId, type])
      .first()

    if (state) {
      try {
        return JSON.parse(state.stateData)
      } catch (error) {
        console.error('Failed to parse collection state:', error)
        return null
      }
    }

    return null
  },

  // 리더보드 관련 함수들
  async updateUserScore(userId: string, category: string, scoreIncrease: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.userScores
      .where(['userId', 'category'])
      .equals([userId, category])
      .first()

    if (existing && existing.id) {
      await db.userScores.update(existing.id, {
        totalScore: existing.totalScore + scoreIncrease,
        lastUpdated: new Date()
      })
    } else {
      const newScore: Omit<UserScore, 'id'> = {
        userId,
        category,
        totalScore: scoreIncrease,
        lastUpdated: new Date()
      }
      await db.userScores.add(newScore)
    }

    return true
  },

  async getUserScore(userId: string, category: string): Promise<number> {
    if (typeof window === 'undefined' || !db) {
      return 0
    }

    const score = await db.userScores
      .where(['userId', 'category'])
      .equals([userId, category])
      .first()

    return score?.totalScore || 0
  },

  async getLeaderboard(category: string, limit = 100): Promise<LeaderboardEntry[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    return await db.leaderboardEntries
      .where('category')
      .equals(category)
      .reverse()
      .sortBy('score')
      .then(entries => entries.slice(0, limit))
  },

  async updateLeaderboardEntry(userId: string, userName: string, category: string, score: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.leaderboardEntries
      .where(['userId', 'category'])
      .equals([userId, category])
      .first()

    if (existing && existing.id) {
      await db.leaderboardEntries.update(existing.id, {
        userName,
        score,
        updatedAt: new Date()
      })
    } else {
      const newEntry: Omit<LeaderboardEntry, 'id'> = {
        userId,
        userName,
        category: category as LeaderboardEntry['category'],
        score,
        createdAt: new Date(),
        updatedAt: new Date()
      }
      await db.leaderboardEntries.add(newEntry)
    }

    return true
  },

  // 리더보드 데이터 가져오기 (leaderboard-service에서 사용)
  async getLeaderboardData(category: string, timeFrame: string, limit = 20): Promise<LeaderboardEntry[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    // 간단한 구현 - 실제로는 timeFrame에 따라 필터링 필요
    const entries = await db.leaderboardEntries
      .where('category')
      .equals(category)
      .reverse()
      .sortBy('score')

    return entries.slice(0, limit).map((entry, index) => ({
      userId: entry.userId,
      userName: entry.userName,
      score: entry.score,
      rank: index + 1,
      level: Math.floor(entry.score / 100) + 1
    }))
  },

  // 사용자 랭킹 데이터 가져오기 (leaderboard-service에서 사용)
  async getUserRankingData(userId: string): Promise<{
    stats: Stat[]
    activities: Activity[]
    totalScore: number
  }> {
    if (typeof window === 'undefined' || !db) {
      return { stats: [], activities: [], totalScore: 0 }
    }

    const stats = await this.getStats(userId)
    const activities = await this.getRecentActivities(userId)
    const totalScore = stats.reduce((sum, stat) => sum + stat.experience, 0)

    return {
      stats: stats.map(stat => ({
        statType: stat.type,
        level: stat.level,
        experience: stat.experience
      })),
      activities,
      totalScore
    }
  },

  // dailyExpLimits 헬퍼 함수
  async checkDailyLimit(userId: string, statType: StatType, requestedExp: number): Promise<number> {
    if (typeof window === 'undefined' || !db) {
      return requestedExp
    }

    // 간단한 구현 - 실제로는 일일 제한 체크 필요
    return requestedExp
  },

  // 던전 스테이지 진행상황 조회 (dungeon-service에서 사용)
  async getDungeonStageProgress(userId: string, dungeonId: string): Promise<StageProgressRecord[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    return await db.stageProgress
      .where(['userId', 'dungeonId'])
      .equals([userId, dungeonId])
      .toArray()
  },

  // 스킬 관련 함수들
  async getLearnedSkills(userId: string): Promise<LearnedSkillData[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.learnedSkills.where('userId').equals(userId).toArray()
  },

  async getLearnedSkill(userId: string, skillId: string): Promise<LearnedSkillData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.learnedSkills
      .where(['userId', 'skillId'])
      .equals([userId, skillId])
      .first() || null
  },

  async saveLearnedSkill(skill: LearnedSkillData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.learnedSkills
      .where(['userId', 'skillId'])
      .equals([skill.userId, skill.skillId])
      .first()

    if (existing && existing.id) {
      await db.learnedSkills.update(existing.id, {
        ...skill,
        id: existing.id
      })
    } else {
      await db.learnedSkills.add(skill)
    }

    return true
  },

  async deleteLearnedSkill(userId: string, skillId: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const skill = await db.learnedSkills
      .where(['userId', 'skillId'])
      .equals([userId, skillId])
      .first()

    if (skill && skill.id) {
      await db.learnedSkills.delete(skill.id)
      return true
    }

    return false
  },

  async getQuickSlots(userId: string): Promise<QuickSlotData[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.quickSlots.where('userId').equals(userId).toArray()
  },

  async saveQuickSlot(slot: QuickSlotData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.quickSlots
      .where(['userId', 'slot'])
      .equals([slot.userId, slot.slot])
      .first()

    if (existing && existing.id) {
      await db.quickSlots.update(existing.id, {
        ...slot,
        id: existing.id,
        updatedAt: new Date()
      })
    } else {
      await db.quickSlots.add({
        ...slot,
        updatedAt: new Date()
      })
    }

    return true
  },

  async clearQuickSlot(userId: string, slotNumber: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const slot = await db.quickSlots
      .where(['userId', 'slot'])
      .equals([userId, slotNumber])
      .first()

    if (slot && slot.id) {
      await db.quickSlots.update(slot.id, {
        skillId: undefined,
        updatedAt: new Date()
      })
      return true
    }

    return false
  },

  async getSkillPoints(userId: string): Promise<SkillPointData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.skillPoints.where('userId').equals(userId).first() || null
  },

  async saveSkillPoints(points: SkillPointData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.skillPoints.where('userId').equals(points.userId).first()

    if (existing && existing.id) {
      await db.skillPoints.update(existing.id, {
        ...points,
        id: existing.id,
        updatedAt: new Date()
      })
    } else {
      await db.skillPoints.add({
        ...points,
        updatedAt: new Date()
      })
    }

    return true
  },

  async addSkillPoints(userId: string, amount: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const current = await this.getSkillPoints(userId)

    if (current) {
      return await this.saveSkillPoints({
        ...current,
        totalPoints: current.totalPoints + amount,
        availablePoints: current.availablePoints + amount
      })
    } else {
      return await this.saveSkillPoints({
        userId,
        totalPoints: amount,
        availablePoints: amount,
        updatedAt: new Date()
      })
    }
  },

  // 던전 진행상황 관련 함수들
  async getDungeonProgress(userId: string, dungeonId: string): Promise<DungeonProgress | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.dungeonProgress
      .where(['userId', 'dungeonId'])
      .equals([userId, dungeonId])
      .first() || null
  },

  async getAllDungeonProgress(userId: string): Promise<DungeonProgress[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.dungeonProgress.where('userId').equals(userId).toArray()
  },

  async createDungeonProgress(progress: DungeonProgress): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    try {
      await db.dungeonProgress.add(progress)
      return true
    } catch (error) {
      console.error('Failed to create dungeon progress:', error)
      return false
    }
  },

  async updateDungeonProgress(
    userId: string,
    dungeonId: string,
    updates: Partial<DungeonProgress>
  ): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.dungeonProgress
      .where(['userId', 'dungeonId'])
      .equals([userId, dungeonId])
      .first()

    if (existing && existing.id) {
      await db.dungeonProgress.update(existing.id, {
        ...updates,
        updatedAt: new Date()
      })
      return true
    }

    return false
  },

  async getCompletedDungeons(userId: string): Promise<DungeonProgress[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.dungeonProgress
      .where('userId')
      .equals(userId)
      .and(progress => progress.status === 'completed')
      .toArray()
  }
}

export default db
