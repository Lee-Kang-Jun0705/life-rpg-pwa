import Dexie, { Table } from 'dexie'
import { DatabaseLock } from './db-lock'
import { calculateLevel } from '../types/dashboard'
import type { StatType } from '../types/game-common'
import type { ActivityVerification, EquipmentInventory } from './types'

// ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤ë“¤
export interface UserProfile {
  id?: number
  userId: string
  email: string
  name: string
  avatar?: string
  level: number
  experience: number // ê¸°ì¡´ í•„ë“œ (deprecated - totalExperienceë¡œ ì´ì „ ì˜ˆì •)
  totalExperience?: number // ëª¨ë“  ìŠ¤íƒ¯ì˜ ì´ ê²½í—˜ì¹˜
  currentExperience?: number // í˜„ì¬ ë ˆë²¨ì—ì„œì˜ ê²½í—˜ì¹˜
  dataVersion?: number // ìŠ¤í‚¤ë§ˆ ë²„ì „ ê´€ë¦¬
  createdAt: Date
  updatedAt: Date
}

export interface Stat {
  id?: number
  userId: string
  type: 'health' | 'learning' | 'relationship' | 'achievement'
  level: number
  experience: number
  totalActivities: number
  updatedAt: Date
}

export interface Activity {
  id?: number
  userId: string
  statType: StatType
  activityName: string
  description?: string
  quality: 'D' | 'C' | 'B' | 'A' | 'S'
  experience: number
  timestamp: Date
  location?: string
  duration?: number // ë¶„ ë‹¨ìœ„
  mediaUrl?: string
  tags?: string[]
  metadata?: {
    device?: string
    appVersion?: string
    method: 'manual' | 'voice' | 'ai_suggestion' | 'quick_action'
    voiceTranscript?: string
    autoGenerated?: boolean
  }
}

export interface Mission {
  id?: number
  userId: string
  title: string
  description: string
  type: 'daily' | 'weekly' | 'monthly' | 'event'
  statType: 'health' | 'learning' | 'relationship' | 'achievement'
  requirements: {
    count: number
    experience: number
  }
  progress: number
  completed: boolean
  rewards: {
    experience: number
    coins?: number
    items?: string[]
  }
  startDate: Date
  endDate: Date
  completedAt?: Date
}

export interface FeedPost {
  id?: number
  userId: string
  content: string
  images?: string[]
  statType?: 'health' | 'learning' | 'relationship' | 'achievement'
  activityId?: number
  likes: number
  comments: number
  createdAt: Date
  updatedAt: Date
  encrypted?: boolean
}

export interface FeedComment {
  id?: number
  postId: number
  userId: string
  content: string
  createdAt: Date
}

export interface FeedReaction {
  id?: number
  postId: number
  userId: string
  type: 'want' | 'respect' | 'support' | 'verify'
  createdAt: Date
}

export interface Investment {
  id?: number
  investorId: string
  recipientId: string
  amount: number
  currency: string
  type: 'investment' | 'donation' | 'sponsorship'
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled'
  description?: string
  receipt?: string
  createdAt: Date
  updatedAt: Date
}

export interface Character {
  id?: number
  userId: string
  appearance: {
    base: string
    hair?: string
    outfit?: string
    accessory?: string
    background?: string
  }
  lastReset: Date
  updatedAt: Date
}

// ì¥ë¹„ ê´€ë ¨ ì¸í„°í˜ì´ìŠ¤ë“¤
export interface UserEquipment {
  id?: number
  userId: string
  equipmentId: string
  type: 'weapon' | 'armor' | 'accessory'
  rarity: 'common' | 'rare' | 'epic' | 'legendary'
  enhancementLevel: number
  isEquipped: boolean
  slot?: string  // 'accessory1' | 'accessory2' | 'accessory3' for accessories
  acquiredAt: Date
  updatedAt: Date
}

// ì•„ì´í…œ ë©”íƒ€ë°ì´í„° íƒ€ì…
export interface ItemMetadata {
  durability?: number
  charges?: number
  expiresAt?: Date
  [key: string]: unknown
}

export interface UserInventory {
  id?: number
  userId: string
  itemType: 'equipment' | 'consumable' | 'material' | 'currency'
  itemId: string
  quantity: number
  metadata?: ItemMetadata  // ì•„ì´í…œë³„ ì¶”ê°€ ì •ë³´
  updatedAt: Date
}

export interface UserResources {
  id?: number
  userId: string
  gold: number
  energy: number
  maxEnergy: number
  lastEnergyUpdate: Date
  premiumCurrency: number
  updatedAt: Date
}

export interface UserAchievement {
  id?: number
  userId: string
  achievementId: string
  progress: number
  completed: boolean
  completedAt?: Date
  claimedAt?: Date
  updatedAt: Date
}

// ì—…ì  ìƒíƒœ ë°ì´í„° íƒ€ì…
export interface AchievementStateData {
  unlockedAchievements: Set<string>
  claimedAchievements: Set<string>
  trackedProgress: Map<string, number>
  statistics: Record<string, number>
}

// ì»¬ë ‰ì…˜ ìƒíƒœ ë°ì´í„° íƒ€ì…
export interface CollectionStateData {
  monsters?: {
    discovered: Set<string>
    firstKills: Map<string, Date>
    killCounts: Map<string, number>
  }
  items?: {
    discovered: Set<string>
    firstObtained: Map<string, Date>
    totalObtained: Map<string, number>
  }
}

export interface AchievementState {
  id?: number
  userId: string
  stateData: string // JSON ë¬¸ìì—´ë¡œ ì €ì¥ëœ AchievementStateData
  updatedAt: Date
}

// í”Œë ˆì´ì–´ ë°ì´í„° íƒ€ì…ë“¤
export type PlayerDataValue =
  | string
  | number
  | boolean
  | Date
  | { [key: string]: PlayerDataValue }
  | PlayerDataValue[]

// í‚¤-ê°’ ì €ì¥ì†Œìš© ì¸í„°í˜ì´ìŠ¤
export interface PlayerData {
  id: string
  data: PlayerDataValue
  updatedAt: Date
}

// ë©”íƒ€ë°ì´í„° ì €ì¥ìš© ì¸í„°í˜ì´ìŠ¤
export interface MetadataEntry {
  id?: number
  key: string
  value: string | number | boolean | Record<string, unknown>
  updatedAt: Date
}

// ì„¤ì • í…Œì´ë¸”ìš© ì¸í„°í˜ì´ìŠ¤
export interface Setting {
  id?: number
  key: string
  value: string
  updatedAt: Date
}

// ìŠ¤í…Œì´ì§€ ì§„í–‰ìƒí™© ì €ì¥ìš© ì¸í„°í˜ì´ìŠ¤
export interface StageProgressRecord {
  id?: number
  userId: string
  dungeonId: string
  stageId: string
  status: 'locked' | 'available' | 'in_progress' | 'completed'
  stars: number
  bestTime?: number
  bestScore?: number
  attempts: number
  objectives: string // JSON string of objectives
  firstClearDate?: Date
  lastAttemptDate?: Date
  createdAt: Date
  updatedAt: Date
}

// ì»¬ë ‰ì…˜ ìƒíƒœ ì €ì¥ìš© ì¸í„°í˜ì´ìŠ¤
export interface CollectionState {
  id?: number
  userId: string
  type: 'monster' | 'item'
  stateData: string // JSON string of collection state
  updatedAt: Date
}

// ë¦¬ë”ë³´ë“œ ì—”íŠ¸ë¦¬
export interface LeaderboardEntry {
  id?: number
  userId: string
  userName: string
  category: 'total_exp' | 'daily_activity' | 'achievement_score' | 'dungeon_clear' | 'stage_clear' | 'collection_score'
  score: number
  rank?: number
  metadata?: string // JSON string for additional data
  createdAt: Date
  updatedAt: Date
}

// ìœ ì €ë³„ ëˆ„ì  ì ìˆ˜
export interface UserScore {
  id?: number
  userId: string
  category: string
  totalScore: number
  lastUpdated: Date
}

// ì—ë„ˆì§€ ì‹œìŠ¤í…œ ì¸í„°í˜ì´ìŠ¤
export interface PlayerEnergyData {
  id?: number
  userId: string
  current: number
  max: number
  lastRegenTime: Date
  lastDailyBonus?: Date
}

export interface BattleTicketData {
  id?: number
  userId: string
  count: number
  lastReset: Date
}

export interface EnergyTransaction {
  id?: number
  userId: string
  type: 'consume' | 'regen' | 'bonus' | 'purchase' | 'refund'
  amount: number
  reason: string
  timestamp: Date
  beforeAmount: number
  afterAmount: number
}

// ì¼ì¼ ê²½í—˜ì¹˜ ì œí•œ
export interface DailyExpLimit {
  id?: number
  userId: string
  statType: StatType
  date: string // YYYY-MM-DD format
  baseLimit: number
  bonusLimit: number
  currentExp: number
  activityCount: number
  uniqueActivities: number
  violations: number
  lastActivityTime: Date
  streakDays: number
}

// í”Œë ˆì´ì–´ ìŠ¤íƒ¯ (ë³„ë„ ê´€ë¦¬)
export interface PlayerStats {
  id?: number
  userId: string
  statType: StatType
  level: number
  experience: number
  totalExp: number
  lastUpdated: Date
}

// í•™ìŠµí•œ ìŠ¤í‚¬
export interface LearnedSkillData {
  id?: number
  userId: string
  skillId: string
  level: number
  experience: number
  cooldownRemaining: number
  isActive: boolean
  slot?: number
  learnedAt: Date
  lastUsed?: Date
}

// í€µìŠ¬ë¡¯ ì„¤ì •
export interface QuickSlotData {
  id?: number
  userId: string
  slot: number // 1-8
  skillId?: string
  updatedAt: Date
}

// ìŠ¤í‚¬ í¬ì¸íŠ¸
export interface SkillPointData {
  id?: number
  userId: string
  totalPoints: number
  availablePoints: number
  updatedAt: Date
}

// ë˜ì „ ì§„í–‰ ìƒí™©
export interface DungeonProgress {
  id?: number
  userId: string
  dungeonId: string
  status: 'available' | 'in_progress' | 'completed' | 'failed'
  attempts: number
  currentChallengeIndex?: number
  completedAt?: Date
  lastAttemptAt?: Date
  energyUsed?: number
  rewards?: {
    exp: number
    coins?: number
    items?: string[]
  }
  createdAt: Date
  updatedAt: Date
}

// í”¼ë¡œë„ ì‹œìŠ¤í…œ
export interface FatigueData {
  id?: number
  userId: string
  currentFatigue: number // 0-100
  activityStreak: number
  lastActivityTime: Date
  lastRestTime: Date
  updatedAt: Date
}

export interface FatigueActivity {
  id?: number
  userId: string
  timestamp: Date
  activityCount: number
  fatigueAdded: number
  efficiency: number
}

// í†µí•© ë°ì´í„°ë² ì´ìŠ¤ í´ë˜ìŠ¤
export class LifeRPGDatabase extends Dexie {
  // ì˜¤í”„ë¼ì¸ ë°ì´í„° í…Œì´ë¸”ë“¤
  profiles!: Table<UserProfile>
  stats!: Table<Stat>
  activities!: Table<Activity>
  missions!: Table<Mission>
  feedPosts!: Table<FeedPost>
  feedComments!: Table<FeedComment>
  feedReactions!: Table<FeedReaction>
  investments!: Table<Investment>
  characters!: Table<Character>

  // ì¥ë¹„ ë° ì¸ë²¤í† ë¦¬ í…Œì´ë¸”ë“¤
  userEquipments!: Table<UserEquipment>
  userInventory!: Table<UserInventory>
  userResources!: Table<UserResources>

  // ì—…ì  ì‹œìŠ¤í…œ í…Œì´ë¸”ë“¤
  userAchievements!: Table<UserAchievement>
  achievementStates!: Table<AchievementState>

  // í‚¤-ê°’ ì €ì¥ì†Œ
  playerData!: Table<PlayerData>
  settings!: Table<Setting>

  // í™•ì¥ í…Œì´ë¸”ë“¤
  stageProgress!: Table<StageProgressRecord>
  collectionStates!: Table<CollectionState>
  leaderboardEntries!: Table<LeaderboardEntry>
  userScores!: Table<UserScore>

  // ì—ë„ˆì§€ ì‹œìŠ¤í…œ í…Œì´ë¸”ë“¤
  playerEnergy!: Table<PlayerEnergyData>
  battleTickets!: Table<BattleTicketData>
  energyTransactions!: Table<EnergyTransaction>
  dailyExpLimits!: Table<DailyExpLimit>

  // ì¶”ê°€ í…Œì´ë¸”
  playerStats!: Table<PlayerStats>
  dungeonProgress!: Table<DungeonProgress>

  // ìŠ¤í‚¬ ì‹œìŠ¤í…œ í…Œì´ë¸”ë“¤
  learnedSkills!: Table<LearnedSkillData>
  quickSlots!: Table<QuickSlotData>
  skillPoints!: Table<SkillPointData>

  // ë©”íƒ€ë°ì´í„° í…Œì´ë¸”
  metadata!: Table<MetadataEntry>

  // í”¼ë¡œë„ ì‹œìŠ¤í…œ í…Œì´ë¸”ë“¤
  fatigue!: Table<FatigueData>
  fatigueActivities!: Table<FatigueActivity>

  // í™œë™ ê²€ì¦ ì‹œìŠ¤í…œ í…Œì´ë¸”
  verifications!: Table<ActivityVerification>

  // JRPG ì‹œìŠ¤í…œ í…Œì´ë¸”ë“¤
  jrpgInventory!: Table<import('./types').JRPGInventory>
  jrpgSkills!: Table<import('./types').JRPGSkills>
  jrpgBattleLogs!: Table<import('./types').JRPGBattleLog>
  jrpgProgress!: Table<import('./types').JRPGProgress>

  constructor() {
    // SSR í™˜ê²½ì—ì„œëŠ” ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ
    if (typeof window === 'undefined') {
      super('LifeRPGDatabase')
      // í…Œì´ë¸”ë“¤ì„ nullë¡œ ì„¤ì •í•˜ì—¬ ì ‘ê·¼ ì‹œ ì˜¤ë¥˜ ë°©ì§€
      this.profiles = null as unknown as Table<UserProfile>
      this.stats = null as unknown as Table<Stat>
      this.activities = null as unknown as Table<Activity>
      this.missions = null as unknown as Table<Mission>
      this.feedPosts = null as unknown as Table<FeedPost>
      this.feedComments = null as unknown as Table<FeedComment>
      this.feedReactions = null as unknown as Table<FeedReaction>
      this.investments = null as unknown as Table<Investment>
      this.characters = null as unknown as Table<Character>
      this.userEquipments = null as unknown as Table<UserEquipment>
      this.userInventory = null as unknown as Table<UserInventory>
      this.userResources = null as unknown as Table<UserResources>
      this.userAchievements = null as unknown as Table<UserAchievement>
      this.achievementStates = null as unknown as Table<AchievementState>
      this.playerData = null as unknown as Table<PlayerData>
      this.settings = null as unknown as Table<Setting>
      this.stageProgress = null as unknown as Table<StageProgressRecord>
      this.collectionStates = null as unknown as Table<CollectionState>
      this.leaderboardEntries = null as unknown as Table<LeaderboardEntry>
      this.userScores = null as unknown as Table<UserScore>
      this.playerEnergy = null as unknown as Table<PlayerEnergyData>
      this.battleTickets = null as unknown as Table<BattleTicketData>
      this.energyTransactions = null as unknown as Table<EnergyTransaction>
      this.dailyExpLimits = null as unknown as Table<DailyExpLimit>
      this.playerStats = null as unknown as Table<PlayerStats>
      this.dungeonProgress = null as unknown as Table<DungeonProgress>
      this.learnedSkills = null as unknown as Table<LearnedSkillData>
      this.quickSlots = null as unknown as Table<QuickSlotData>
      this.skillPoints = null as unknown as Table<SkillPointData>
      this.metadata = null as unknown as Table<MetadataEntry>
      this.fatigue = null as unknown as Table<FatigueData>
      this.fatigueActivities = null as unknown as Table<FatigueActivity>
      this.verifications = null as unknown as Table<ActivityVerification>
      this.jrpgInventory = null as unknown as Table<import('./types').JRPGInventory>
      this.jrpgSkills = null as unknown as Table<import('./types').JRPGSkills>
      this.jrpgBattleLogs = null as unknown as Table<import('./types').JRPGBattleLog>
      this.jrpgProgress = null as unknown as Table<import('./types').JRPGProgress>
      return
    }

    super('LifeRPGDatabase')

    // ë²„ì „ 1: ê¸°ë³¸ í…Œì´ë¸”ë“¤
    this.version(1).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      playerData: 'id, updatedAt'
    })

    // ë²„ì „ 2: í”¼ë“œ ë° íˆ¬ì ê¸°ëŠ¥ ì¶”ê°€
    this.version(2).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      playerData: 'id, updatedAt'
    })

    // ë²„ì „ 3: stats í…Œì´ë¸” ê°œì„  (ë‹¨ìˆœí•œ ìŠ¤í‚¤ë§ˆ ì •ì˜ë§Œ)
    this.version(3).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId', // ìœ ë‹ˆí¬ ì œì•½ì¡°ê±´ ì œê±°, ì¸ë±ìŠ¤ë§Œ ìœ ì§€
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      playerData: 'id, updatedAt'
    })

    // ë²„ì „ 4: characters í…Œì´ë¸” ì¶”ê°€
    this.version(4).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt'
    })

    // ë²„ì „ 5: settings í…Œì´ë¸” ì¶”ê°€
    this.version(5).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key'
    })

    // ë²„ì „ 6: ì¥ë¹„ ë° ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ ì¶”ê°€
    this.version(6).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key',
      userEquipments: '++id, userId, equipmentId, [userId+isEquipped]',
      userInventory: '++id, userId, [userId+itemType], [userId+itemId]',
      userResources: '++id, userId'
    })

    // ë²„ì „ 7: ì—…ì  ì‹œìŠ¤í…œ ì¶”ê°€
    this.version(7).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key',
      userEquipments: '++id, userId, equipmentId, [userId+isEquipped]',
      userInventory: '++id, userId, [userId+itemType], [userId+itemId]',
      userResources: '++id, userId',
      userAchievements: '++id, userId, achievementId, [userId+completed]',
      achievementStates: '++id, userId'
    })

    // ë²„ì „ 8: í™•ì¥ í…Œì´ë¸” ì¶”ê°€ (ë˜ì „, ì»¬ë ‰ì…˜, ë¦¬ë”ë³´ë“œ)
    this.version(8).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key',
      userEquipments: '++id, userId, equipmentId, [userId+isEquipped]',
      userInventory: '++id, userId, [userId+itemType], [userId+itemId]',
      userResources: '++id, userId',
      userAchievements: '++id, userId, achievementId, [userId+completed]',
      achievementStates: '++id, userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId'
    })

    // ë²„ì „ 9: dungeonProgress í…Œì´ë¸” ì¶”ê°€
    this.version(9).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: '++id, key',
      userEquipments: '++id, userId, equipmentId, [userId+isEquipped]',
      userInventory: '++id, userId, [userId+itemType], [userId+itemId]',
      userResources: '++id, userId',
      userAchievements: '++id, userId, achievementId, [userId+completed]',
      achievementStates: '++id, userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt'
    })

    // ë²„ì „ 11: ìŠ¤í‚¬ ì‹œìŠ¤í…œ í…Œì´ë¸” ì¶”ê°€
    this.version(11).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key'
    })

    // ë²„ì „ 12: í”¼ë¡œë„ ì‹œìŠ¤í…œ í…Œì´ë¸” ì¶”ê°€
    this.version(12).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key',
      fatigue: '++id, userId',
      fatigueActivities: '++id, userId, timestamp'
    })

    // ë²„ì „ 13: í™œë™ ê²€ì¦ ì‹œìŠ¤í…œ í…Œì´ë¸” ì¶”ê°€
    this.version(13).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key',
      fatigue: '++id, userId',
      fatigueActivities: '++id, userId, timestamp',
      verifications: '++id, [userId+activityId], userId, timestamp, type, verified'
    })

    // ë²„ì „ 14: í”„ë¡œí•„ ìŠ¤í‚¤ë§ˆ v2 - totalExperience, currentExperience í•„ë“œ ì¶”ê°€
    this.version(14).stores({
      profiles: '++id, userId, email', // ì¸ë±ìŠ¤ëŠ” ë™ì¼
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key',
      fatigue: '++id, userId',
      fatigueActivities: '++id, userId, timestamp',
      verifications: '++id, [userId+activityId], userId, timestamp, type, verified'
    }).upgrade(async trans => {
      // í”„ë¡œí•„ ë§ˆì´ê·¸ë ˆì´ì…˜: totalExperienceì™€ currentExperience í•„ë“œ ì¶”ê°€
      const profiles = await trans.profiles.toArray()
      const stats = await trans.stats.toArray()

      for (const profile of profiles) {
        // í•´ë‹¹ ì‚¬ìš©ìì˜ ëª¨ë“  ìŠ¤íƒ¯ ê²½í—˜ì¹˜ í•©ê³„ ê³„ì‚°
        const userStats = stats.filter(s => s.userId === profile.userId)
        const totalExp = userStats.reduce((sum, stat) => sum + stat.experience, 0)

        // stat-calculatorì˜ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ ê²½í—˜ì¹˜ ê³„ì‚°
        const { calculateLevelFromExperience } = await import('@/lib/utils/stat-calculator')
        const { level, currentExp } = calculateLevelFromExperience(totalExp)

        // í”„ë¡œí•„ ì—…ë°ì´íŠ¸
        await trans.profiles.update(profile.id!, {
          totalExperience: totalExp,
          currentExperience: currentExp,
          level: level, // ë ˆë²¨ë„ ì¬ê³„ì‚°í•˜ì—¬ ì—…ë°ì´íŠ¸
          dataVersion: 2,
          updatedAt: new Date()
        })
      }
    })

    // ë²„ì „ 15: JRPG ì‹œìŠ¤í…œ í…Œì´ë¸” ì¶”ê°€
    this.version(15).stores({
      profiles: '++id, userId, email',
      stats: '++id, [userId+type], userId',
      activities: '++id, userId, statType, timestamp',
      missions: '++id, userId, type, completed, [userId+type]',
      feedPosts: '++id, userId, createdAt, encrypted',
      feedComments: '++id, postId, userId, createdAt',
      feedReactions: '++id, [postId+userId+type], postId, userId',
      investments: '++id, investorId, recipientId, status, createdAt',
      characters: '++id, userId',
      playerData: 'id, updatedAt',
      settings: 'id, category, userId',
      userEquipments: '++id, userId, equipmentId, isEquipped',
      userInventory: '++id, userId, itemId, itemType',
      userResources: '++id, userId',
      userAchievements: '++id, [userId+achievementId], userId, achievementId, unlockedAt',
      achievementStates: 'userId',
      stageProgress: '++id, [userId+dungeonId+stageId], userId, dungeonId, stageId, status',
      collectionStates: '++id, [userId+type], userId, type',
      leaderboardEntries: '++id, [category+rank], userId, category, score',
      userScores: '++id, [userId+category], userId, category',
      playerEnergy: '++id, userId',
      battleTickets: '++id, userId',
      energyTransactions: '++id, userId, type, timestamp',
      dailyExpLimits: '++id, [userId+statType+date], userId, date',
      playerStats: '++id, [userId+statType], userId',
      dungeonProgress: '++id, [userId+dungeonId], userId, dungeonId, status, completedAt',
      learnedSkills: '++id, [userId+skillId], userId, skillId, level, slot',
      quickSlots: '++id, [userId+slot], userId, slot',
      skillPoints: '++id, userId',
      metadata: '++id, key',
      fatigue: '++id, userId',
      fatigueActivities: '++id, userId, timestamp',
      verifications: '++id, [userId+activityId], userId, timestamp, type, verified',
      // JRPG í…Œì´ë¸”ë“¤
      jrpgInventory: '++id, userId',
      jrpgSkills: '++id, userId',
      jrpgBattleLogs: '++id, userId, dungeonId, timestamp',
      jrpgProgress: '++id, userId'
    })
  }
}

// SSRì—ì„œ ì•ˆì „í•œ ë”ë¯¸ ë°ì´í„°ë² ì´ìŠ¤ ê°ì²´
class DummyDatabase extends Dexie {
  profiles!: Dexie.Table<UserProfile, number>
  stats!: Dexie.Table<Stat, number>
  activities!: Dexie.Table<Activity, number>
  missions!: Dexie.Table<Mission, number>
  feedPosts!: Dexie.Table<FeedPost, number>
  feedComments!: Dexie.Table<FeedComment, number>
  feedReactions!: Dexie.Table<FeedReaction, number>
  investments!: Dexie.Table<Investment, number>
  characters!: Dexie.Table<Character, number>
  playerData!: Dexie.Table<PlayerData, string>
  settings!: Dexie.Table<Setting, number>

  constructor() {
    super('DummyDB')
    // SSRì—ì„œëŠ” ì‹¤ì œë¡œ ì‚¬ìš©ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë²„ì „ë§Œ ì„¤ì •
    this.version(1).stores({})
  }
}

// ë°ì´í„°ë² ì´ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (í´ë¼ì´ì–¸íŠ¸ì—ì„œë§Œ)
export const db: LifeRPGDatabase = typeof window !== 'undefined'
  ? new LifeRPGDatabase()
  : new DummyDatabase() as unknown as LifeRPGDatabase

// ë°ì´í„°ë² ì´ìŠ¤ í—¬í¼ í•¨ìˆ˜ë“¤
export const dbHelpers = {
  // í”„ë¡œí•„ ê´€ë ¨
  async getProfile(userId: string): Promise<UserProfile | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.profiles.where('userId').equals(userId).first() || null
  },

  async updateProfile(userId: string, updates: Partial<UserProfile>) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    const profile = await this.getProfile(userId)
    if (profile) {
      return await db.profiles.update(profile.id!, { ...updates, updatedAt: new Date() })
    }
    return null
  },

  // ìŠ¤íƒ¯ ê´€ë ¨
  async getStats(userId: string) {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    let stats = await db.stats.where('userId').equals(userId).toArray()

    // ìŠ¤íƒ¯ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ìŠ¤íƒ¯ ìƒì„±
    if (stats.length === 0) {
      const defaultStats: Omit<Stat, 'id'>[] = [
        {
          userId,
          type: 'health',
          level: 0,
          experience: 0,
          totalActivities: 0,
          updatedAt: new Date()
        },
        {
          userId,
          type: 'learning',
          level: 0,
          experience: 0,
          totalActivities: 0,
          updatedAt: new Date()
        },
        {
          userId,
          type: 'relationship',
          level: 0,
          experience: 0,
          totalActivities: 0,
          updatedAt: new Date()
        },
        {
          userId,
          type: 'achievement',
          level: 0,
          experience: 0,
          totalActivities: 0,
          updatedAt: new Date()
        }
      ]

      for (const stat of defaultStats) {
        await db.stats.add(stat)
      }

      // ìƒˆë¡œ ìƒì„±ëœ ìŠ¤íƒ¯ë“¤ ë°˜í™˜
      stats = await db.stats.where('userId').equals(userId).toArray()
    }

    return stats
  },

  async saveStat(stat: Stat) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    // userIdì™€ typeìœ¼ë¡œ ê¸°ì¡´ ìŠ¤íƒ¯ ì°¾ê¸°
    const userStats = await db.stats.where('userId').equals(stat.userId).toArray()
    const existing = userStats.find((s) => s.type === stat.type)

    if (existing) {
      // ê¸°ì¡´ ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
      return await db.stats.update(existing.id!, {
        ...stat,
        id: existing.id,
        updatedAt: new Date()
      })
    } else {
      // ìƒˆ ìŠ¤íƒ¯ ì¶”ê°€
      return await db.stats.add(stat)
    }
  },

  async updateStat(userId: string, type: Stat['type'], experience: number) {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    // í•´ë‹¹ ì‚¬ìš©ìì˜ ëª¨ë“  ìŠ¤íƒ¯ ê°€ì ¸ì™€ì„œ í•„í„°ë§
    const userStats = await db.stats.where('userId').equals(userId).toArray()
    const stat = userStats.find((s) => s.type === type)

    if (stat) {
      const newExperience = stat.experience + experience
      const { level: newLevel } = calculateLevel(newExperience)
      return await db.stats.update(stat.id!, {
        experience: newExperience,
        level: newLevel,
        totalActivities: stat.totalActivities + 1,
        updatedAt: new Date()
      })
    } else {
      // ìŠ¤íƒ¯ì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
      const { level: newLevel } = calculateLevel(experience)
      const newStat: Omit<Stat, 'id'> = {
        userId,
        type,
        level: newLevel,
        experience,
        totalActivities: 1,
        updatedAt: new Date()
      }
      return await db.stats.add(newStat)
    }
  },

  // í™œë™ ê´€ë ¨
  async addActivity(activity: Omit<Activity, 'id'>) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    const id = await db.activities.add(activity)
    // ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
    await this.updateStat(activity.userId, activity.statType, activity.experience)

    // ì˜¤í”„ë¼ì¸ì¼ ë•Œ ë™ê¸°í™” ëŒ€ê¸°ì—´ì— ì¶”ê°€ - ë‚˜ì¤‘ì— êµ¬í˜„
    // if (!navigator.onLine) {
    //   // TODO: Implement sync queue
    // }

    // ì „ì²´ í™œë™ ê°ì²´ ë°˜í™˜
    return { ...activity, id }
  },

  async getActivities(userId: string, limit?: number) {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    const query = db.activities
      .where('userId')
      .equals(userId)
      .reverse()

    if (limit) {
      return await query.limit(limit).toArray()
    }

    return await query.toArray()
  },

  async deleteActivity(id: number) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.activities.delete(id)
  },

  async getRecentActivities(userId: string, limit = 10) {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.activities
      .where('userId')
      .equals(userId)
      .reverse()
      .sortBy('timestamp')
      .then((activities) => activities.slice(0, limit))
  },


  async getActivitiesByDateRange(userId: string, startDate: Date, endDate: Date) {
    return await db.activities
      .where('userId')
      .equals(userId)
      .and((activity) => activity.timestamp >= startDate && activity.timestamp <= endDate)
      .toArray()
  },

  // ë¯¸ì…˜ ê´€ë ¨
  async getActiveMissions(userId: string) {
    const now = new Date()
    return await db.missions
      .where('userId')
      .equals(userId)
      .and((mission) => !mission.completed && mission.endDate > now)
      .toArray()
  },

  async updateMissionProgress(missionId: number, progress: number) {
    const mission = await db.missions.get(missionId)
    if (mission) {
      const completed = progress >= mission.requirements.count
      return await db.missions.update(missionId, {
        progress,
        completed,
        completedAt: completed ? new Date() : undefined
      })
    }
  },

  // í”Œë ˆì´ì–´ ë°ì´í„° (í‚¤-ê°’ ì €ì¥ì†Œ)
  async getPlayerData(key: string): Promise<PlayerData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.playerData.get(key) || null
  },

  async setPlayerData(key: string, data: PlayerDataValue) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.playerData.put({
      id: key,
      data,
      updatedAt: new Date()
    })
  },


  // ì´ˆê¸° ë°ì´í„° ì„¤ì •
  async initializeUserData(userId: string, email: string, name: string) {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return DatabaseLock.acquire(`init-${userId}`, async() => {
      // í”„ë¡œí•„ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
      const existingProfile = await db.profiles.where('userId').equals(userId).first()

      if (!existingProfile) {
        // í”„ë¡œí•„ ìƒì„±
        await db.profiles.add({
          userId,
          email,
          name,
          level: 0,
          experience: 0,
          createdAt: new Date(),
          updatedAt: new Date()
        })
      }

      // ì´ˆê¸° ìŠ¤íƒ¯ ìƒì„± (íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì²˜ë¦¬)
      await db.transaction('rw', db.stats, async() => {
        const statTypes: Stat['type'][] = ['health', 'learning', 'relationship', 'achievement']

        for (const type of statTypes) {
          // ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
          const existing = await db.stats
            .where('[userId+type]')
            .equals([userId, type])
            .first()

          if (!existing) {
            console.log(`ğŸ“ Creating stat: ${type}`)
            await db.stats.add({
              userId,
              type,
              level: 0,
              experience: 0,
              totalActivities: 0,
              updatedAt: new Date()
            })
          } else {
            console.log(`âœ… Stat already exists: ${type}`)
          }
        }
      })
    })
  },

  // ì¤‘ë³µëœ ìŠ¤íƒ¯ ì œê±°
  async removeDuplicateStats(userId: string) {
    if (typeof window === 'undefined' || !db) {
      return { removed: 0, remaining: 0 }
    }
    return db.transaction('rw', db.stats, async() => {
      const stats = await db.stats.where('userId').equals(userId).toArray()
      const uniqueStats = new Map<string, Stat>()

      console.log(`ğŸ” Checking ${stats.length} stats for duplicates...`)

      // ê° íƒ€ì…ë³„ë¡œ ê°€ì¥ ë†’ì€ ë ˆë²¨ê³¼ ê²½í—˜ì¹˜ë¥¼ ê°€ì§„ ìŠ¤íƒ¯ë§Œ ìœ ì§€
      for (const stat of stats) {
        const existing = uniqueStats.get(stat.type)
        if (!existing ||
            stat.level > existing.level ||
            (stat.level === existing.level && stat.experience > existing.experience)) {
          uniqueStats.set(stat.type, stat)
        }
      }

      // ì¤‘ë³µëœ ìŠ¤íƒ¯ì´ ìˆëŠ” ê²½ìš° ì²˜ë¦¬
      if (stats.length > uniqueStats.size) {
        console.log(`ğŸ§¹ Removing duplicate stats: ${stats.length} â†’ ${uniqueStats.size}`)

        // ëª¨ë“  ìŠ¤íƒ¯ ì‚­ì œ
        await db.stats.where('userId').equals(userId).delete()

        // ìœ ë‹ˆí¬í•œ ìŠ¤íƒ¯ë§Œ ë‹¤ì‹œ ì €ì¥ (ID ì—†ì´)
        const newStats = []
        for (const stat of uniqueStats.values()) {
          const newStat = {
            userId: stat.userId,
            type: stat.type,
            level: stat.level,
            experience: stat.experience,
            totalActivities: stat.totalActivities,
            updatedAt: new Date()
          }
          await db.stats.add(newStat)
          newStats.push(newStat)
        }

        console.log(`âœ… Duplicates removed. New stats:`, newStats.map(s => s.type))
        return { removed: stats.length - uniqueStats.size, remaining: uniqueStats.size }
      }

      console.log('âœ… No duplicates found')
      return { removed: 0, remaining: stats.length }
    })
  },

  // ì¥ë¹„ ê´€ë ¨ í•¨ìˆ˜ë“¤
  async getUserEquipments(userId: string): Promise<UserEquipment[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.userEquipments.where('userId').equals(userId).toArray()
  },

  // ì¥ë¹„ ì¸ë²¤í† ë¦¬ ê°€ì ¸ì˜¤ê¸° (player.serviceì—ì„œ ì‚¬ìš©)
  async getEquipmentInventory(userId: string): Promise<EquipmentInventory | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    const equipments = await db.userEquipments
      .where('userId')
      .equals(userId)
      .toArray()

    if (!equipments.length) {
      return {
        id: 0,
        userId,
        maxSlots: 100,
        currentSlots: 0,
        items: [],
        createdAt: new Date(),
        updatedAt: new Date()
      }
    }

    // userEquipmentsë¥¼ EquipmentInventory í˜•ì‹ìœ¼ë¡œ ë³€í™˜
    const items = equipments.map(eq => ({
      id: eq.id!,
      inventoryId: 0, // ì„ì‹œ
      itemId: eq.equipmentId,
      type: eq.type,
      rarity: eq.rarity,
      level: 1,
      enhancement: eq.enhancementLevel || 0,
      isEquipped: eq.isEquipped,
      equippedSlot: eq.slot || null,
      obtainedAt: eq.acquiredAt,
      locked: false
    }))

    return {
      id: 0,
      userId,
      maxSlots: 100,
      currentSlots: items.length,
      items,
      createdAt: new Date(),
      updatedAt: new Date()
    }
  },

  async getEquippedItems(userId: string): Promise<UserEquipment[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.userEquipments
      .where('userId')
      .equals(userId)
      .and(item => item.isEquipped === true)
      .toArray()
  },

  async equipItem(userId: string, equipmentId: string, slot?: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const equipment = await db.userEquipments
      .where({ userId, equipmentId })
      .first()

    if (!equipment) {
      return false
    }

    await db.userEquipments.update(equipment.id!, {
      isEquipped: true,
      slot: slot,
      updatedAt: new Date()
    })

    return true
  },

  async unequipItem(userId: string, equipmentId: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const equipment = await db.userEquipments
      .where({ userId, equipmentId })
      .first()

    if (!equipment) {
      return false
    }

    await db.userEquipments.update(equipment.id!, {
      isEquipped: false,
      slot: undefined,
      updatedAt: new Date()
    })

    return true
  },

  async addEquipmentToInventory(userId: string, equipmentId: string, type: string, rarity: string): Promise<number | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    const equipment: Omit<UserEquipment, 'id'> = {
      userId,
      equipmentId,
      type: type as UserEquipment['type'],
      rarity: rarity as UserEquipment['rarity'],
      enhancementLevel: 0,
      isEquipped: false,
      acquiredAt: new Date(),
      updatedAt: new Date()
    }

    return await db.userEquipments.add(equipment)
  },

  // ë¦¬ì†ŒìŠ¤ ê´€ë ¨ í•¨ìˆ˜ë“¤
  async getUserResources(userId: string): Promise<UserResources | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    let resources = await db.userResources.where('userId').equals(userId).first()

    if (!resources) {
      // ê¸°ë³¸ ë¦¬ì†ŒìŠ¤ ìƒì„±
      const defaultResources: Omit<UserResources, 'id'> = {
        userId,
        gold: 1000,
        energy: 100,
        maxEnergy: 100,
        lastEnergyUpdate: new Date(),
        premiumCurrency: 0,
        updatedAt: new Date()
      }

      await db.userResources.add(defaultResources)
      resources = await db.userResources.where('userId').equals(userId).first()
    }

    return resources || null
  },

  async updateUserResources(userId: string, updates: Partial<UserResources>): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const resources = await this.getUserResources(userId)
    if (!resources) {
      return false
    }

    await db.userResources.update(resources.id!, {
      ...updates,
      updatedAt: new Date()
    })

    return true
  },

  async spendGold(userId: string, amount: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const resources = await this.getUserResources(userId)
    if (!resources || resources.gold < amount) {
      return false
    }

    await this.updateUserResources(userId, {
      gold: resources.gold - amount
    })

    return true
  },

  async addGold(userId: string, amount: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const resources = await this.getUserResources(userId)
    if (!resources) {
      return false
    }

    await this.updateUserResources(userId, {
      gold: resources.gold + amount
    })

    return true
  },

  // ì¸ë²¤í† ë¦¬ ê´€ë ¨ í•¨ìˆ˜ë“¤
  async getInventoryItems(userId: string, itemType?: string): Promise<UserInventory[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    if (itemType) {
      return await db.userInventory
        .where(['userId', 'itemType'])
        .equals([userId, itemType])
        .toArray()
    }

    return await db.userInventory.where('userId').equals(userId).toArray()
  },

  async addInventoryItem(userId: string, itemType: string, itemId: string, quantity = 1): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existingItem = await db.userInventory
      .where(['userId', 'itemId'])
      .equals([userId, itemId])
      .first()

    if (existingItem) {
      await db.userInventory.update(existingItem.id!, {
        quantity: existingItem.quantity + quantity,
        updatedAt: new Date()
      })
    } else {
      const newItem: Omit<UserInventory, 'id'> = {
        userId,
        itemType: itemType as UserInventory['itemType'],
        itemId,
        quantity,
        updatedAt: new Date()
      }
      await db.userInventory.add(newItem)
    }

    return true
  },

  async removeInventoryItem(userId: string, itemId: string, quantity = 1): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const item = await db.userInventory
      .where(['userId', 'itemId'])
      .equals([userId, itemId])
      .first()

    if (!item || item.quantity < quantity) {
      return false
    }

    if (item.quantity === quantity) {
      await db.userInventory.delete(item.id!)
    } else {
      await db.userInventory.update(item.id!, {
        quantity: item.quantity - quantity,
        updatedAt: new Date()
      })
    }

    return true
  },

  // ì—…ì  ê´€ë ¨ í•¨ìˆ˜ë“¤
  async getUserAchievements(userId: string): Promise<UserAchievement[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.userAchievements.where('userId').equals(userId).toArray()
  },

  async updateAchievementProgress(userId: string, achievementId: string, progress: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const achievement = await db.userAchievements
      .where(['userId', 'achievementId'])
      .equals([userId, achievementId])
      .first()

    if (achievement) {
      await db.userAchievements.update(achievement.id!, {
        progress,
        updatedAt: new Date()
      })
    } else {
      const newAchievement: Omit<UserAchievement, 'id'> = {
        userId,
        achievementId,
        progress,
        completed: false,
        updatedAt: new Date()
      }
      await db.userAchievements.add(newAchievement)
    }

    return true
  },

  async completeAchievement(userId: string, achievementId: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const achievement = await db.userAchievements
      .where(['userId', 'achievementId'])
      .equals([userId, achievementId])
      .first()

    if (achievement) {
      await db.userAchievements.update(achievement.id!, {
        completed: true,
        completedAt: new Date(),
        updatedAt: new Date()
      })
    } else {
      const newAchievement: Omit<UserAchievement, 'id'> = {
        userId,
        achievementId,
        progress: 100,
        completed: true,
        completedAt: new Date(),
        updatedAt: new Date()
      }
      await db.userAchievements.add(newAchievement)
    }

    return true
  },

  async claimAchievementReward(userId: string, achievementId: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const achievement = await db.userAchievements
      .where(['userId', 'achievementId'])
      .equals([userId, achievementId])
      .first()

    if (achievement && achievement.completed && !achievement.claimedAt) {
      await db.userAchievements.update(achievement.id!, {
        claimedAt: new Date(),
        updatedAt: new Date()
      })
      return true
    }

    return false
  },

  async saveAchievementState(userId: string, stateData: AchievementStateData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.achievementStates.where('userId').equals(userId).first()

    if (existing) {
      await db.achievementStates.update(existing.id!, {
        stateData: JSON.stringify(stateData),
        updatedAt: new Date()
      })
    } else {
      const newState: Omit<AchievementState, 'id'> = {
        userId,
        stateData: JSON.stringify(stateData),
        updatedAt: new Date()
      }
      await db.achievementStates.add(newState)
    }

    return true
  },

  async loadAchievementState(userId: string): Promise<AchievementStateData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    const state = await db.achievementStates.where('userId').equals(userId).first()

    if (state) {
      try {
        return JSON.parse(state.stateData)
      } catch (error) {
        console.error('Failed to parse achievement state:', error)
        return null
      }
    }

    return null
  },

  // ìŠ¤í…Œì´ì§€ ì§„í–‰ìƒí™© ê´€ë ¨ í•¨ìˆ˜ë“¤
  async getStageProgress(userId: string, dungeonId: string, stageId: string): Promise<StageProgressRecord | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.stageProgress
      .where(['userId', 'dungeonId', 'stageId'])
      .equals([userId, dungeonId, stageId])
      .first() || null
  },

  async updateStageProgress(userId: string, dungeonId: string, stageId: string, updates: Partial<StageProgressRecord>): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await this.getStageProgress(userId, dungeonId, stageId)

    if (existing && existing.id) {
      await db.stageProgress.update(existing.id, {
        ...updates,
        updatedAt: new Date()
      })
    } else {
      const newProgress: Omit<StageProgressRecord, 'id'> = {
        userId,
        dungeonId,
        stageId,
        status: updates.status || 'locked',
        stars: updates.stars || 0,
        bestTime: updates.bestTime,
        bestScore: updates.bestScore,
        attempts: updates.attempts || 0,
        objectives: updates.objectives || '[]',
        firstClearDate: updates.firstClearDate,
        lastAttemptDate: updates.lastAttemptDate,
        createdAt: new Date(),
        updatedAt: new Date()
      }
      await db.stageProgress.add(newProgress)
    }

    return true
  },

  async getAllStageProgress(userId: string, dungeonId?: string): Promise<StageProgressRecord[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    if (dungeonId) {
      return await db.stageProgress
        .where(['userId', 'dungeonId'])
        .equals([userId, dungeonId])
        .toArray()
    }

    return await db.stageProgress.where('userId').equals(userId).toArray()
  },

  // ì»¬ë ‰ì…˜ ê´€ë ¨ í•¨ìˆ˜ë“¤
  async saveCollectionState(userId: string, state: CollectionStateData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const type = state.monsters ? 'monster' : 'item'
    const existing = await db.collectionStates
      .where(['userId', 'type'])
      .equals([userId, type])
      .first()

    if (existing && existing.id) {
      await db.collectionStates.update(existing.id, {
        stateData: JSON.stringify(state),
        updatedAt: new Date()
      })
    } else {
      const newState: Omit<CollectionState, 'id'> = {
        userId,
        type: type as 'monster' | 'item',
        stateData: JSON.stringify(state),
        updatedAt: new Date()
      }
      await db.collectionStates.add(newState)
    }

    return true
  },

  async loadCollectionState(userId: string, type: 'monster' | 'item'): Promise<CollectionStateData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }

    const state = await db.collectionStates
      .where(['userId', 'type'])
      .equals([userId, type])
      .first()

    if (state) {
      try {
        return JSON.parse(state.stateData)
      } catch (error) {
        console.error('Failed to parse collection state:', error)
        return null
      }
    }

    return null
  },

  // ë¦¬ë”ë³´ë“œ ê´€ë ¨ í•¨ìˆ˜ë“¤
  async updateUserScore(userId: string, category: string, scoreIncrease: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.userScores
      .where(['userId', 'category'])
      .equals([userId, category])
      .first()

    if (existing && existing.id) {
      await db.userScores.update(existing.id, {
        totalScore: existing.totalScore + scoreIncrease,
        lastUpdated: new Date()
      })
    } else {
      const newScore: Omit<UserScore, 'id'> = {
        userId,
        category,
        totalScore: scoreIncrease,
        lastUpdated: new Date()
      }
      await db.userScores.add(newScore)
    }

    return true
  },

  async getUserScore(userId: string, category: string): Promise<number> {
    if (typeof window === 'undefined' || !db) {
      return 0
    }

    const score = await db.userScores
      .where(['userId', 'category'])
      .equals([userId, category])
      .first()

    return score?.totalScore || 0
  },

  async getLeaderboard(category: string, limit = 100): Promise<LeaderboardEntry[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    return await db.leaderboardEntries
      .where('category')
      .equals(category)
      .reverse()
      .sortBy('score')
      .then(entries => entries.slice(0, limit))
  },

  async updateLeaderboardEntry(userId: string, userName: string, category: string, score: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.leaderboardEntries
      .where(['userId', 'category'])
      .equals([userId, category])
      .first()

    if (existing && existing.id) {
      await db.leaderboardEntries.update(existing.id, {
        userName,
        score,
        updatedAt: new Date()
      })
    } else {
      const newEntry: Omit<LeaderboardEntry, 'id'> = {
        userId,
        userName,
        category: category as LeaderboardEntry['category'],
        score,
        createdAt: new Date(),
        updatedAt: new Date()
      }
      await db.leaderboardEntries.add(newEntry)
    }

    return true
  },

  // ë¦¬ë”ë³´ë“œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (leaderboard-serviceì—ì„œ ì‚¬ìš©)
  async getLeaderboardData(category: string, timeFrame: string, limit = 20): Promise<LeaderboardEntry[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    // ê°„ë‹¨í•œ êµ¬í˜„ - ì‹¤ì œë¡œëŠ” timeFrameì— ë”°ë¼ í•„í„°ë§ í•„ìš”
    const entries = await db.leaderboardEntries
      .where('category')
      .equals(category)
      .reverse()
      .sortBy('score')

    return entries.slice(0, limit).map((entry, index) => ({
      userId: entry.userId,
      userName: entry.userName,
      score: entry.score,
      rank: index + 1,
      level: Math.floor(entry.score / 100) + 1
    }))
  },

  // ì‚¬ìš©ì ë­í‚¹ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (leaderboard-serviceì—ì„œ ì‚¬ìš©)
  async getUserRankingData(userId: string): Promise<{
    stats: Stat[]
    activities: Activity[]
    totalScore: number
  }> {
    if (typeof window === 'undefined' || !db) {
      return { stats: [], activities: [], totalScore: 0 }
    }

    const stats = await this.getStats(userId)
    const activities = await this.getRecentActivities(userId)
    const totalScore = stats.reduce((sum, stat) => sum + stat.experience, 0)

    return {
      stats: stats.map(stat => ({
        statType: stat.type,
        level: stat.level,
        experience: stat.experience
      })),
      activities,
      totalScore
    }
  },

  // dailyExpLimits í—¬í¼ í•¨ìˆ˜
  async checkDailyLimit(userId: string, statType: StatType, requestedExp: number): Promise<number> {
    if (typeof window === 'undefined' || !db) {
      return requestedExp
    }

    // ê°„ë‹¨í•œ êµ¬í˜„ - ì‹¤ì œë¡œëŠ” ì¼ì¼ ì œí•œ ì²´í¬ í•„ìš”
    return requestedExp
  },

  // ë˜ì „ ìŠ¤í…Œì´ì§€ ì§„í–‰ìƒí™© ì¡°íšŒ (dungeon-serviceì—ì„œ ì‚¬ìš©)
  async getDungeonStageProgress(userId: string, dungeonId: string): Promise<StageProgressRecord[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }

    return await db.stageProgress
      .where(['userId', 'dungeonId'])
      .equals([userId, dungeonId])
      .toArray()
  },

  // ìŠ¤í‚¬ ê´€ë ¨ í•¨ìˆ˜ë“¤
  async getLearnedSkills(userId: string): Promise<LearnedSkillData[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.learnedSkills.where('userId').equals(userId).toArray()
  },

  async getLearnedSkill(userId: string, skillId: string): Promise<LearnedSkillData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.learnedSkills
      .where(['userId', 'skillId'])
      .equals([userId, skillId])
      .first() || null
  },

  async saveLearnedSkill(skill: LearnedSkillData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.learnedSkills
      .where(['userId', 'skillId'])
      .equals([skill.userId, skill.skillId])
      .first()

    if (existing && existing.id) {
      await db.learnedSkills.update(existing.id, {
        ...skill,
        id: existing.id
      })
    } else {
      await db.learnedSkills.add(skill)
    }

    return true
  },

  async deleteLearnedSkill(userId: string, skillId: string): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const skill = await db.learnedSkills
      .where(['userId', 'skillId'])
      .equals([userId, skillId])
      .first()

    if (skill && skill.id) {
      await db.learnedSkills.delete(skill.id)
      return true
    }

    return false
  },

  async getQuickSlots(userId: string): Promise<QuickSlotData[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.quickSlots.where('userId').equals(userId).toArray()
  },

  async saveQuickSlot(slot: QuickSlotData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.quickSlots
      .where(['userId', 'slot'])
      .equals([slot.userId, slot.slot])
      .first()

    if (existing && existing.id) {
      await db.quickSlots.update(existing.id, {
        ...slot,
        id: existing.id,
        updatedAt: new Date()
      })
    } else {
      await db.quickSlots.add({
        ...slot,
        updatedAt: new Date()
      })
    }

    return true
  },

  async clearQuickSlot(userId: string, slotNumber: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const slot = await db.quickSlots
      .where(['userId', 'slot'])
      .equals([userId, slotNumber])
      .first()

    if (slot && slot.id) {
      await db.quickSlots.update(slot.id, {
        skillId: undefined,
        updatedAt: new Date()
      })
      return true
    }

    return false
  },

  async getSkillPoints(userId: string): Promise<SkillPointData | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.skillPoints.where('userId').equals(userId).first() || null
  },

  async saveSkillPoints(points: SkillPointData): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.skillPoints.where('userId').equals(points.userId).first()

    if (existing && existing.id) {
      await db.skillPoints.update(existing.id, {
        ...points,
        id: existing.id,
        updatedAt: new Date()
      })
    } else {
      await db.skillPoints.add({
        ...points,
        updatedAt: new Date()
      })
    }

    return true
  },

  async addSkillPoints(userId: string, amount: number): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const current = await this.getSkillPoints(userId)

    if (current) {
      return await this.saveSkillPoints({
        ...current,
        totalPoints: current.totalPoints + amount,
        availablePoints: current.availablePoints + amount
      })
    } else {
      return await this.saveSkillPoints({
        userId,
        totalPoints: amount,
        availablePoints: amount,
        updatedAt: new Date()
      })
    }
  },

  // ë˜ì „ ì§„í–‰ìƒí™© ê´€ë ¨ í•¨ìˆ˜ë“¤
  async getDungeonProgress(userId: string, dungeonId: string): Promise<DungeonProgress | null> {
    if (typeof window === 'undefined' || !db) {
      return null
    }
    return await db.dungeonProgress
      .where(['userId', 'dungeonId'])
      .equals([userId, dungeonId])
      .first() || null
  },

  async getAllDungeonProgress(userId: string): Promise<DungeonProgress[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.dungeonProgress.where('userId').equals(userId).toArray()
  },

  async createDungeonProgress(progress: DungeonProgress): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    try {
      await db.dungeonProgress.add(progress)
      return true
    } catch (error) {
      console.error('Failed to create dungeon progress:', error)
      return false
    }
  },

  async updateDungeonProgress(
    userId: string,
    dungeonId: string,
    updates: Partial<DungeonProgress>
  ): Promise<boolean> {
    if (typeof window === 'undefined' || !db) {
      return false
    }

    const existing = await db.dungeonProgress
      .where(['userId', 'dungeonId'])
      .equals([userId, dungeonId])
      .first()

    if (existing && existing.id) {
      await db.dungeonProgress.update(existing.id, {
        ...updates,
        updatedAt: new Date()
      })
      return true
    }

    return false
  },

  async getCompletedDungeons(userId: string): Promise<DungeonProgress[]> {
    if (typeof window === 'undefined' || !db) {
      return []
    }
    return await db.dungeonProgress
      .where('userId')
      .equals(userId)
      .and(progress => progress.status === 'completed')
      .toArray()
  }
}

export default db
